name: Build Curated App List

on:
  schedule:
    # Run weekly on Sundays at 00:00 UTC
    - cron: '0 0 * * 0'
  workflow_dispatch:
    inputs:
      limit:
        description: 'Maximum number of apps to import (0 = all)'
        required: false
        default: '0'
      force_refresh:
        description: 'Force refresh all apps (update even if unchanged)'
        required: false
        default: 'false'
        type: boolean

# Prevent concurrent runs that could cause database conflicts
concurrency:
  group: curated-apps-pipeline
  cancel-in-progress: false

env:
  NODE_VERSION: '20'
  WINGET_INDEX_URL: 'https://raw.githubusercontent.com/svrooij/winget-pkgs-index/main/index.v2.json'

permissions:
  contents: read

jobs:
  build-app-list:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Fetch winget package index
        id: fetch
        run: |
          echo "Fetching winget-pkgs-index from svrooij..."
          curl -sL "$WINGET_INDEX_URL" -o winget-index.json

          # Validate JSON
          if ! jq empty winget-index.json 2>/dev/null; then
            echo "ERROR: Invalid JSON received"
            exit 1
          fi

          TOTAL=$(jq 'length' winget-index.json)
          echo "Fetched index with $TOTAL packages"
          echo "total_packages=$TOTAL" >> $GITHUB_OUTPUT

      - name: Import packages to Supabase
        id: import
        env:
          SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          IMPORT_LIMIT: ${{ github.event.inputs.limit || '0' }}
          FORCE_REFRESH: ${{ github.event.inputs.force_refresh || 'false' }}
        run: |
          node << 'EOF'
          const fs = require('fs');
          const { createClient } = require('@supabase/supabase-js');

          const supabaseUrl = process.env.SUPABASE_URL;
          const supabaseKey = process.env.SUPABASE_SERVICE_KEY;

          if (!supabaseUrl || !supabaseKey) {
            console.log('Supabase credentials not configured, skipping sync');
            process.exit(0);
          }

          const supabase = createClient(supabaseUrl, supabaseKey);

          async function importPackages() {
            const importLimit = parseInt(process.env.IMPORT_LIMIT || '0', 10);
            const forceRefresh = process.env.FORCE_REFRESH === 'true';

            // Update sync status to running
            await supabase.from('curated_sync_status').upsert({
              id: 'build-app-list',
              last_run_started_at: new Date().toISOString(),
              last_run_status: 'running',
              updated_at: new Date().toISOString()
            });

            // Load winget index
            const rawIndex = fs.readFileSync('winget-index.json', 'utf8');
            let packages = JSON.parse(rawIndex);

            console.log(`Loaded ${packages.length} packages from winget index`);

            // Apply limit if specified (for testing)
            if (importLimit > 0 && packages.length > importLimit) {
              console.log(`Limiting to ${importLimit} packages (for testing)`);
              packages = packages.slice(0, importLimit);
            }

            // ---------------------------------------------------------------
            // Locale detection for language variant grouping
            // Known locale codes (ISO 639-1 + common BCP 47 subtags)
            // ---------------------------------------------------------------
            const LOCALE_CODES = new Set([
              'aa','ab','af','ak','am','an','ar','as','ast','av','ay','az',
              'ba','be','bg','bm','bn','bo','br','bs',
              'ca','ce','cak','ch','co','cr','cs','cu','cv','cy',
              'da','de','dsb','dv','dz',
              'ee','el','en-CA','en-GB','en-US','eo','es-AR','es-CL','es-ES','es-MX',
              'et','eu',
              'fa','ff','fi','fj','fo','fr','fur','fy-NL',
              'ga-IE','gd','gl','gn','gu-IN',
              'ha','he','hi-IN','ho','hr','hsb','ht','hu','hy-AM',
              'ia','id','ig','ii','ik','io','is','it',
              'ja','jv',
              'ka','kab','kg','ki','kk','kl','km','kn','ko','ks','ku','kv','kw','ky',
              'la','lb','lg','li','lij','ln','lo','lt','lu','lv',
              'mg','mh','mi','mk','ml','mn','mr','ms','mt','my',
              'na','nb-NO','nd','ne-NP','ng','nl','nn-NO','no','nr','nv','ny',
              'oc','oj','om','or','os',
              'pa-IN','pi','pl','ps','pt-BR','pt-PT',
              'qu',
              'rm','rn','ro','ru','rw',
              'sa','sc','sco','sd','se','sg','si','sk','sl','sm','sn','so','son','sq','sr','ss','st','su','sv-SE','sw','szl',
              'ta','te','tg','th','ti','tk','tl','tn','to','tr','trs','ts','tt','tw','ty',
              'ug','uk','ur','uz',
              'vi','vo',
              'wa','wo',
              'xh',
              'yi','yo',
              'za','zh-CN','zh-TW','zu'
            ]);

            // Whitelist of parent package IDs eligible for locale variant grouping.
            // Add more entries here as needed (e.g., 'LibreOffice.LibreOffice').
            const LOCALE_VARIANT_PARENTS = new Set([
              'Mozilla.Firefox',
            ]);

            function detectLocaleVariant(packageId) {
              const parts = packageId.split('.');
              if (parts.length < 3) return null;

              const lastPart = parts[parts.length - 1];
              const lastTwoParts = parts.length >= 4
                ? parts[parts.length - 2] + '-' + lastPart
                : null;

              // Check compound locale first (e.g., "es-ES", "pt-BR", "fy-NL")
              if (lastTwoParts && LOCALE_CODES.has(lastTwoParts)) {
                const parentId = parts.slice(0, -2).join('.');
                if (!LOCALE_VARIANT_PARENTS.has(parentId)) return null;
                return { parentId, locale: lastTwoParts };
              }

              // Check single locale code (e.g., "de", "fr", "ja")
              // Only match if the segment is lowercase (BCP 47 convention).
              if (lastPart === lastPart.toLowerCase() && LOCALE_CODES.has(lastPart)) {
                const parentId = parts.slice(0, -1).join('.');
                if (!LOCALE_VARIANT_PARENTS.has(parentId)) return null;
                return { parentId, locale: lastPart };
              }

              return null;
            }

            // Transform packages to our schema
            // Index v2 format: { Name, PackageId, Version, Tags, LastUpdate }

            // First pass: build a set of all package IDs so we can validate parents
            const allPackageIds = new Set(
              packages.map(pkg => pkg.PackageId || pkg.PackageIdentifier || '').filter(Boolean)
            );

            const appsToUpsert = packages.map(pkg => {
              // Extract publisher from PackageId (first part before .)
              const packageId = pkg.PackageId || pkg.PackageIdentifier || '';
              const parts = packageId.split('.');
              const publisher = parts[0] || 'Unknown';

              // Detect locale variant
              const localeInfo = detectLocaleVariant(packageId);
              // Only mark as variant if the parent package also exists in the index
              const isVariant = localeInfo !== null && allPackageIds.has(localeInfo.parentId);

              return {
                winget_id: packageId,
                name: pkg.Name || pkg.PackageName || packageId,
                publisher: publisher,
                latest_version: pkg.Version || null,
                tags: pkg.Tags || [],
                winget_last_update: pkg.LastUpdate || null,
                is_verified: true, // Source is authoritative (winget-pkgs)
                is_winget_verified: true,
                parent_winget_id: isVariant ? localeInfo.parentId : null,
                locale_code: isVariant ? localeInfo.locale : null,
                is_locale_variant: isVariant,
                updated_at: new Date().toISOString()
              };
            }).filter(app => app.winget_id); // Filter out any entries without ID

            const variantCount = appsToUpsert.filter(a => a.is_locale_variant).length;
            console.log(`Prepared ${appsToUpsert.length} apps for upsert (${variantCount} locale variants detected)`);

            // Upsert in batches to handle scale
            const batchSize = 500;
            let totalUpserted = 0;
            let errors = 0;

            try {
              for (let i = 0; i < appsToUpsert.length; i += batchSize) {
                const batch = appsToUpsert.slice(i, i + batchSize);

                const { error } = await supabase
                  .from('curated_apps')
                  .upsert(batch, {
                    onConflict: 'winget_id',
                    ignoreDuplicates: false
                  });

                if (error) {
                  console.error(`Batch ${Math.floor(i / batchSize) + 1} failed:`, error.message);
                  errors++;
                  // Continue with next batch
                } else {
                  totalUpserted += batch.length;
                }

                // Progress logging every 10 batches
                if ((i / batchSize) % 10 === 0) {
                  console.log(`Progress: ${Math.min(i + batchSize, appsToUpsert.length)}/${appsToUpsert.length}`);
                }

                // Small delay between batches to avoid rate limiting
                if (i + batchSize < appsToUpsert.length) {
                  await new Promise(r => setTimeout(r, 100));
                }
              }

              // Icon inheritance: copy parent icon_path to locale variants
              if (variantCount > 0) {
                const { data: iconCount, error: iconError } = await supabase.rpc('inherit_parent_icons');
                if (iconError) {
                  console.log('Icon inheritance: skipped (function may not exist yet):', iconError.message);
                } else {
                  console.log(`Icon inheritance: updated ${iconCount || 0} variant icons from parent apps`);
                }
              }

              // Update sync status to success
              await supabase.from('curated_sync_status').upsert({
                id: 'build-app-list',
                last_run_completed_at: new Date().toISOString(),
                last_run_status: errors > 0 && totalUpserted === 0 ? 'failed' : 'success',
                items_processed: totalUpserted,
                error_message: errors > 0 ? `${errors} batches failed` : null,
                metadata: {
                  source: 'winget-pkgs-index',
                  total_packages: packages.length,
                  upserted: totalUpserted,
                  batch_errors: errors
                },
                updated_at: new Date().toISOString()
              });

              console.log(`\nImport complete:`);
              console.log(`  - Total packages in index: ${packages.length}`);
              console.log(`  - Successfully upserted: ${totalUpserted}`);
              console.log(`  - Locale variants detected: ${variantCount}`);
              console.log(`  - Batch errors: ${errors}`);

              // Output stats for workflow
              fs.writeFileSync('./import-stats.json', JSON.stringify({
                total: packages.length,
                upserted: totalUpserted,
                locale_variants: variantCount,
                errors: errors
              }));

            } catch (error) {
              // Update sync status to failed
              await supabase.from('curated_sync_status').upsert({
                id: 'build-app-list',
                last_run_status: 'failed',
                error_message: error.message,
                updated_at: new Date().toISOString()
              });

              console.error('Import failed:', error.message);
              process.exit(1);
            }
          }

          importPackages().then(() => {
            process.exit(0);
          }).catch((err) => {
            console.error('Unexpected error:', err);
            process.exit(1);
          });
          EOF

          echo "import_complete=true" >> $GITHUB_OUTPUT

      - name: Create summary
        run: |
          if [ -f import-stats.json ]; then
            TOTAL=$(jq -r '.total' import-stats.json)
            UPSERTED=$(jq -r '.upserted' import-stats.json)
            VARIANTS=$(jq -r '.locale_variants // 0' import-stats.json)
            ERRORS=$(jq -r '.errors' import-stats.json)

            echo "## Curated App List Build Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Source: winget-pkgs-index" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **Total packages in index:** $TOTAL" >> $GITHUB_STEP_SUMMARY
            echo "- **Successfully imported:** $UPSERTED" >> $GITHUB_STEP_SUMMARY
            echo "- **Locale variants detected:** $VARIANTS" >> $GITHUB_STEP_SUMMARY
            echo "- **Batch errors:** $ERRORS" >> $GITHUB_STEP_SUMMARY
            echo "- **Generated at:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "This workflow now sources directly from the winget-pkgs-index maintained by svrooij, which is updated every 4 hours from the official Microsoft winget-pkgs repository." >> $GITHUB_STEP_SUMMARY
          fi
